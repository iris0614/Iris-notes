[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Iris-notes",
    "section": "",
    "text": "Hiüëã, I am Iris LUO. Welcome to my collection of LeetCode notesüìù! üåü\nI‚Äôve compiled these notes to help others on their coding journey. Most of the explanations here are based on the concepts and materials from the UBC Master of Data Science (MDS)course. For any additional references or specific problem explanations, I‚Äôll be sharing links throughout. Whether you‚Äôre a beginner or just looking for a quick refresher, I hope you find these notes both useful and enjoyable! \nKey Highlights:\n\nüîçDeep Dives: Detailed explanations of common coding problems.\nüí°Tips & Tricks: Handy shortcuts and insights to boost your problem-solving speed.\nüõ†Ô∏èCode Snippets: Ready-to-use code examples to help you ace your interviews. Feel free to explore, and happy coding! üöÄ"
  },
  {
    "objectID": "sql.html",
    "href": "sql.html",
    "title": "SQL",
    "section": "",
    "text": "What is a database?\n\nOrganized collection of related data\n\nWhat is a database management system (DBMS)?\n\nCollection of programs that enables users to create and maintain a database\nallows users to create, query, modify, and manage\n\n\nDATABASE != DBMS\n\n\n\nEfficiency: Data is stored efficiently.\nIntegrity: Data is consistent and correct.\nSecurity: Data is safe from unauthorized access.\nConcurrent Access: Multiple users can access the same data at the same time.\nCrash Recovery: Data is safe from crashes.\nIndependence: Data is independent of the programs that use it.\n\n\n\n\n\n\nWorks with entities and relationships\nEntity: a thing or object in the real world that is distinguishable from other objects\n\ne.g.¬†students in a school\n\nRelationship: an association among entities\n\ne.g.¬†a student is enrolled in a course\n\n\n\n\n\n\nA relation is an instance of a relation schema (just like an object was an instance of a class!)\nRelation Schema specifies:\n\nName of a relation\nName and domain of each attribute\n\nDomain: A set of constraints that determines the type, length, format, range, uniqueness and nullability of values stored for an attribute.\n\n\n\n\n\n\nQuery: A question that we ask about the data. The result of a query is a new relation.\nStructured Query Language (SQL): A programming language taht we use to talk to a relational DBMS. SQL != relational model != database != DBMS SQL is a standard language for storing, manipulating and retrieving data in databases.\nThe data query language(DQL) is part of a bigger set of languages for working with data in a realational database, which consists of:\n\nData Definition Language (DDL) for creating, altering and deleting tables.\nData Manipulation Language (DML) for inserting new data, updating values, etc.\nData Query Language (DQL) for quering and retrieving data.\nData Control Language (DCL) for management and controlling user access, rights and privileges.\n\n\n\n\n\n\nIt is an open-source, cross-platform DBMS that implements the relational model.\n\n\n\n\n\n\nCommand\nUsage\n\n\n\n\n\\l\nList all databases\n\n\n\\c\nConnect to a database\n\n\n\\d\nDescribe tables and views\n\n\n\\dt\nList tables\n\n\n\\dt+\nList tables with additional info\n\n\n\\d+\nList tables and views with additional info\n\n\n\\!\nExecute shell commands\n\n\n\\cd\nChange directory\n\n\n\\i\nExecute commands from a file\n\n\n\\h\nView help on SQL commands\n\n\n\\?\nView help on psql meta commands\n\n\n\\q\nQuit interactive shell\n\n\n\nNote that you don‚Äôt need to terminate meta commands with ;.\n\n\n\n\n\n\n\nFROM and JOIN\nWHERE\nGROUP BY\nHAVING\nSELECT\nDISTINCT\nORDER BY\nLIMIT\n\n\n\n\n\nSELECT\nFROM\nJOIN\nWHERE\nGROUP BY\nHAVING\nORDER BY\nLIMIT\n\n\n\n\n\narithmetic oprators(e.g.¬†+, *)\ncomparison operators(e.g.¬†&gt;, &lt;=)\nlogical operators(e.g.¬†NOT, AND, OR)\n\n\n\n\n\nNOT\nAND\nOR\n\nIn SQL, using () (parentheses) changes the order of evaluation for logical operators. Expressions within parentheses are evaluated first, ensuring the intended logic is applied.\n\n\n\n\nHow we convert values from one type to another. In standard SQL, type conversion can be done using the CAST function: CAST(&lt;column&gt; AS &lt;data_type&gt;). In Postgres, we can also use the double-colon syntax as a shorthand for the above CAST function: &lt;column&gt;::&lt;data_type&gt;.\nBoolean, BOOLEAN or BOOL\n\nTrue: TRUE, t, true, y, yes, YES, Y, T, 1(or any other positive integer)\nFalse: FALSE, 0, NO, N, F\n\nCharacters\n\nCHAR(n): a string of exactly n characters padded with spaces.\nVARCHAR(n): a variable set of n characters.\nTEXT: Postgres specific type for which there is practically no limit on the number of characters.\n\nDateTime: date and time\n\nDATE: date (YYYY-MM-DD)\n\nCURRENT_DATE: current date\n\nTIME: time\nTIMESTAMP: date and time\nTIMESTAMPTZ: date and time with timezone\n\nBinary: binary data\nNumbers:\nIntegers\n\n\n\n\n\n\n\n\n\n\nName\nStorage Size\nDescription\nRange\n\n\n\n\nsmallint\n2 bytes\nsmall-range integer\n-32,768 to +32,767\n\n\ninteger\n4 bytes\ntypical choice for integer\n-2,147,483,648 to +2,147,483,647\n\n\nbigint\n8 bytes\nlarge-range integer\n-9,223,372,036,854,775,808 to +9,223,372,036,854,775,807\n\n\nserial\n4 bytes\nauto-incrementing integer\n1 to 2,147,483,647\n\n\nbigserial\n8 bytes\nlarge auto-incrementing integer\n1 to 9,223,372,036,854,775,807\n\n\n\n\nFloating-point numbers\n\n\n\n\n\n\n\n\n\n\nName\nStorage Size\nDescription\nRange\n\n\n\n\nreal\n4 bytes\nvariable-precision, inexact\nat least 6 decimal digits (implementation dependent)\n\n\ndouble precision\n8 bytes\nvariable-precision, inexact\nat least 15 decimal digits (implementation dependent)\n\n\n\n\nArbitrary precision numbers\n\n\n\n\n\n\n\n\n\n\nName\nStorage Size\nDescription\nRange\n\n\n\n\nnumeric or decimal\nvariable\nuser-specified precision, exact\n131072 digits before and 16383 digits after the decimal point\n\n\n\nNote:With the numeric data type, we can specify the total number of significant digits to store (known as precision) as well as the number of digits in the fractional part (known as scale) by specifying NUMERIC(precision, scale):SELECT CAST(‚Äò183.123456789‚Äô AS NUMERIC(5, 2)); 183.12\n\nDate/time:\n\nDATE: dates (YYYY-MM-DD)\nTIME: the time of day\nTIMESTAMP: date + time\nTIMESTAMPTZ: date + time + timezone\nIntervals: storing intervals of time '3 years 2 months 23 hours 8 minutes 18s'::INTERVAL 1155 days, 23:08:18\n\n\nNOW() and CURRENT_TIMESTAMP are equivalent, with the latter being SQL-standard.\nWhen you use the NOW() function in SQL, the timezone of the timestamp it returns depends on the timezone setting of the database server, not your local computer.\n\n\n\nA null is marker to indicate that the value for a column is unknown, or not entered yet.A null is not equal to 0, or an empty string. In fact, a null is not even equal to another null!\nHow different environments show nulls:\n\nipython-sql -&gt; None\npsql -&gt; blank space\npgAdmin -&gt; [null]\n\n\n\n\n\n\n\n\n\n\n\nCondition Example\nDescription\n\n\n\n\nWHERE column = value\nEquals; returns true if the column equals the value.\n\n\nWHERE column &lt;&gt; value\nNot equals; true if the column is not equal to value.\n\n\nWHERE column &gt; value\nGreater than; true if the column is more than value.\n\n\nWHERE column &lt; value\nLess than; true if the column is less than value.\n\n\nWHERE column BETWEEN value1 AND value2\nTrue if the column is within the range of value1 and value2.\n\n\nWHERE column [NOT] IN (value1, value2, ...)\nTrue if the column is [NOT] equal to any of multiple values.\n\n\nWHERE column [NOT] LIKE pattern\nTrue if the column [NOT] matches the SQL pattern.\n\n\nWHERE column IS [NOT] NULL\nTrue if the column is [NOT] NULL.\n\n\n\nNote that in SQL, strings are enclosed in single quotes, i.e.¬†‚Äòstring‚Äô.\nWhile SQL syntax is case-insensitive, string comparisons in SQL can be case-sensitive depending on the database system and collation settings. For example, in some systems, ‚ÄòLost highway‚Äô will not return any rows if the actual data is ‚ÄòLost Highway‚Äô.\n\n\n\nPostgres provides us with two wild-cards that we can use with LIKE: - % matches any string of characters. - _ matches a single character.\n\nPattern matching with LIKE is case sensitive;\nPostgres also provides the ILIKE keyword that has the same functionality as LIKE but is case-insensitive.\nWith LIKE or ILIKE, the entire string should match the pattern.\nUsing ESCAPE to identify escape character: e.g.¬†WHERE column LIKE '%$%%' ESCAPE '$': matches strings that contains %.\n\n\n\n\nSELECT column1, column2\nFROM table1\nWHERE column1 = value1 OR column1 = value2 OR column1 = value3\n;\nThis can be rewritten more succinctly using the IN operator:\nSELECT column1, column2\nFROM table1\nWHERE column1 IN (value1, value2, value3)\n:\n\n\n\nSelect a range of values, and it can be used for number(BETWEEN 1 AND 5), character(BETWEEN 'e' AND 'm') and datetime(BETWEEN DATE '2021-01-01' AND '2021-11-10').\nBETWEEN is inclusive of both ends of the interval.\n\n\n\nTrying to find NULL values using WHERE column = NULL fails. This is because a NULL value is by defination not known and could be anything, so it‚Äôs not necessarily equal to another NULL. To find NULL values in a column, we can use IS [NOT] NULL.\n\n\n\nIn SQL, we are not required to use the same column and table names in the schema.\n\n\n\nDerived columns in SQL are columns taht are the result of doing operations on existing columns of a table.\nSELECT title, runtime/60. AS runtime_hours\nFROM movies;\nif you divide by 60 instead, SQL assumes that the result of this operation should also be an integer(given that the column runtime is also of type integer), and will return truncated integer values instead of floats.\nSQL doesn‚Äôt know what to call the derived column, and by default you will see ?column? as the column name. We can use an alias to name the new derived column.\nSELECT statement is powerful, but not dangerous. Derived columns returned by Postgres are not saved anywhere, nor do they change existing columns.\n\n\n\nIt enables us to treat a column differently based on the values in each row.\nSELECT \n  title, \n  runtime,\n  CASE\n    WHEN runtime &gt; 90 THEN 'long'\n    WHEN runtime BETWEEN 30 AND 90 THEN 'normal'\n    ELSE 'short'\n  END AS duration\nFROM \n  movies\n;\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n%\nmodulo (remainder)\n\n\n^\nexponentiation\n\n\n@\nabsolute value\n\n\n\n\n\n\nDescription\nExample\n\n\n\n\nabsolute value\nabs(-17.4)\n\n\nsmallest integer not less than argument\nceil(-42.8)\n\n\nexponential\nexp(1.0)\n\n\nlargest integer not greater than argument\nfloor(-42.8)\n\n\nnatural logarithm\nln(2.0)\n\n\nlogarithm to base b\nlog(2.0, 64.0)\n\n\n‚ÄúœÄ‚Äù constant\npi()\n\n\na raised to the power of b\npower(9.0, 3.0)\n\n\nround to s decimal places\nround(42.4382, 2)\n\n\nsquare root\nsqrt(2.0)\n\n\n\nROUND() function only works with the NUMERIC (or equivalently DECIMAL) data type.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nstring || string\nString concatenation\n\n\nstring || non-string or non-string || string\nString concatenation with one non-string input\n\n\nchar_length(string) or character_length(string)\nNumber of characters in string\n\n\nlower(string)\nConvert string to lower case\n\n\nposition(substring in string)\nLocation of specified substring\n\n\nsubstring(string)\nExtract substring\n\n\nupper(string)\nConvert string to upper case\n\n\nlength(string)\nNumber of characters in string\n\n\n\nSELECT\n  UPPER(title),\n  SUBSTRING(title FROM 1 FOR 3) AS \"First 3 characters\",\n  SUBSTRING(title, LENGTH(title) - 3, 3) AS \"LAST 3 characters\"\nFROM\n  movies\n;\n\n\n\nNULLIF(value1, value2) returns null if value1 and value2 are equal. This is helpful for replacing known values with nulls, or prevent, for example, division by zero."
  },
  {
    "objectID": "sql.html#introduction",
    "href": "sql.html#introduction",
    "title": "SQL",
    "section": "",
    "text": "What is a database?\n\nOrganized collection of related data\n\nWhat is a database management system (DBMS)?\n\nCollection of programs that enables users to create and maintain a database\nallows users to create, query, modify, and manage\n\n\nDATABASE != DBMS\n\n\n\nEfficiency: Data is stored efficiently.\nIntegrity: Data is consistent and correct.\nSecurity: Data is safe from unauthorized access.\nConcurrent Access: Multiple users can access the same data at the same time.\nCrash Recovery: Data is safe from crashes.\nIndependence: Data is independent of the programs that use it."
  },
  {
    "objectID": "sql.html#relational-data-model",
    "href": "sql.html#relational-data-model",
    "title": "SQL",
    "section": "",
    "text": "Works with entities and relationships\nEntity: a thing or object in the real world that is distinguishable from other objects\n\ne.g.¬†students in a school\n\nRelationship: an association among entities\n\ne.g.¬†a student is enrolled in a course"
  },
  {
    "objectID": "sql.html#relational-database-a-collection-of-relations.",
    "href": "sql.html#relational-database-a-collection-of-relations.",
    "title": "SQL",
    "section": "",
    "text": "A relation is an instance of a relation schema (just like an object was an instance of a class!)\nRelation Schema specifies:\n\nName of a relation\nName and domain of each attribute\n\nDomain: A set of constraints that determines the type, length, format, range, uniqueness and nullability of values stored for an attribute."
  },
  {
    "objectID": "sql.html#query-language-in-a-dbms",
    "href": "sql.html#query-language-in-a-dbms",
    "title": "SQL",
    "section": "",
    "text": "Query: A question that we ask about the data. The result of a query is a new relation.\nStructured Query Language (SQL): A programming language taht we use to talk to a relational DBMS. SQL != relational model != database != DBMS SQL is a standard language for storing, manipulating and retrieving data in databases.\nThe data query language(DQL) is part of a bigger set of languages for working with data in a realational database, which consists of:\n\nData Definition Language (DDL) for creating, altering and deleting tables.\nData Manipulation Language (DML) for inserting new data, updating values, etc.\nData Query Language (DQL) for quering and retrieving data.\nData Control Language (DCL) for management and controlling user access, rights and privileges."
  },
  {
    "objectID": "sql.html#postgresql",
    "href": "sql.html#postgresql",
    "title": "SQL",
    "section": "",
    "text": "It is an open-source, cross-platform DBMS that implements the relational model.\n\n\n\n\n\n\nCommand\nUsage\n\n\n\n\n\\l\nList all databases\n\n\n\\c\nConnect to a database\n\n\n\\d\nDescribe tables and views\n\n\n\\dt\nList tables\n\n\n\\dt+\nList tables with additional info\n\n\n\\d+\nList tables and views with additional info\n\n\n\\!\nExecute shell commands\n\n\n\\cd\nChange directory\n\n\n\\i\nExecute commands from a file\n\n\n\\h\nView help on SQL commands\n\n\n\\?\nView help on psql meta commands\n\n\n\\q\nQuit interactive shell\n\n\n\nNote that you don‚Äôt need to terminate meta commands with ;."
  },
  {
    "objectID": "sql.html#sql-commands",
    "href": "sql.html#sql-commands",
    "title": "SQL",
    "section": "",
    "text": "FROM and JOIN\nWHERE\nGROUP BY\nHAVING\nSELECT\nDISTINCT\nORDER BY\nLIMIT\n\n\n\n\n\nSELECT\nFROM\nJOIN\nWHERE\nGROUP BY\nHAVING\nORDER BY\nLIMIT\n\n\n\n\n\narithmetic oprators(e.g.¬†+, *)\ncomparison operators(e.g.¬†&gt;, &lt;=)\nlogical operators(e.g.¬†NOT, AND, OR)\n\n\n\n\n\nNOT\nAND\nOR\n\nIn SQL, using () (parentheses) changes the order of evaluation for logical operators. Expressions within parentheses are evaluated first, ensuring the intended logic is applied.\n\n\n\n\nHow we convert values from one type to another. In standard SQL, type conversion can be done using the CAST function: CAST(&lt;column&gt; AS &lt;data_type&gt;). In Postgres, we can also use the double-colon syntax as a shorthand for the above CAST function: &lt;column&gt;::&lt;data_type&gt;.\nBoolean, BOOLEAN or BOOL\n\nTrue: TRUE, t, true, y, yes, YES, Y, T, 1(or any other positive integer)\nFalse: FALSE, 0, NO, N, F\n\nCharacters\n\nCHAR(n): a string of exactly n characters padded with spaces.\nVARCHAR(n): a variable set of n characters.\nTEXT: Postgres specific type for which there is practically no limit on the number of characters.\n\nDateTime: date and time\n\nDATE: date (YYYY-MM-DD)\n\nCURRENT_DATE: current date\n\nTIME: time\nTIMESTAMP: date and time\nTIMESTAMPTZ: date and time with timezone\n\nBinary: binary data\nNumbers:\nIntegers\n\n\n\n\n\n\n\n\n\n\nName\nStorage Size\nDescription\nRange\n\n\n\n\nsmallint\n2 bytes\nsmall-range integer\n-32,768 to +32,767\n\n\ninteger\n4 bytes\ntypical choice for integer\n-2,147,483,648 to +2,147,483,647\n\n\nbigint\n8 bytes\nlarge-range integer\n-9,223,372,036,854,775,808 to +9,223,372,036,854,775,807\n\n\nserial\n4 bytes\nauto-incrementing integer\n1 to 2,147,483,647\n\n\nbigserial\n8 bytes\nlarge auto-incrementing integer\n1 to 9,223,372,036,854,775,807\n\n\n\n\nFloating-point numbers\n\n\n\n\n\n\n\n\n\n\nName\nStorage Size\nDescription\nRange\n\n\n\n\nreal\n4 bytes\nvariable-precision, inexact\nat least 6 decimal digits (implementation dependent)\n\n\ndouble precision\n8 bytes\nvariable-precision, inexact\nat least 15 decimal digits (implementation dependent)\n\n\n\n\nArbitrary precision numbers\n\n\n\n\n\n\n\n\n\n\nName\nStorage Size\nDescription\nRange\n\n\n\n\nnumeric or decimal\nvariable\nuser-specified precision, exact\n131072 digits before and 16383 digits after the decimal point\n\n\n\nNote:With the numeric data type, we can specify the total number of significant digits to store (known as precision) as well as the number of digits in the fractional part (known as scale) by specifying NUMERIC(precision, scale):SELECT CAST(‚Äò183.123456789‚Äô AS NUMERIC(5, 2)); 183.12\n\nDate/time:\n\nDATE: dates (YYYY-MM-DD)\nTIME: the time of day\nTIMESTAMP: date + time\nTIMESTAMPTZ: date + time + timezone\nIntervals: storing intervals of time '3 years 2 months 23 hours 8 minutes 18s'::INTERVAL 1155 days, 23:08:18\n\n\nNOW() and CURRENT_TIMESTAMP are equivalent, with the latter being SQL-standard.\nWhen you use the NOW() function in SQL, the timezone of the timestamp it returns depends on the timezone setting of the database server, not your local computer.\n\n\n\nA null is marker to indicate that the value for a column is unknown, or not entered yet.A null is not equal to 0, or an empty string. In fact, a null is not even equal to another null!\nHow different environments show nulls:\n\nipython-sql -&gt; None\npsql -&gt; blank space\npgAdmin -&gt; [null]\n\n\n\n\n\n\n\n\n\n\n\nCondition Example\nDescription\n\n\n\n\nWHERE column = value\nEquals; returns true if the column equals the value.\n\n\nWHERE column &lt;&gt; value\nNot equals; true if the column is not equal to value.\n\n\nWHERE column &gt; value\nGreater than; true if the column is more than value.\n\n\nWHERE column &lt; value\nLess than; true if the column is less than value.\n\n\nWHERE column BETWEEN value1 AND value2\nTrue if the column is within the range of value1 and value2.\n\n\nWHERE column [NOT] IN (value1, value2, ...)\nTrue if the column is [NOT] equal to any of multiple values.\n\n\nWHERE column [NOT] LIKE pattern\nTrue if the column [NOT] matches the SQL pattern.\n\n\nWHERE column IS [NOT] NULL\nTrue if the column is [NOT] NULL.\n\n\n\nNote that in SQL, strings are enclosed in single quotes, i.e.¬†‚Äòstring‚Äô.\nWhile SQL syntax is case-insensitive, string comparisons in SQL can be case-sensitive depending on the database system and collation settings. For example, in some systems, ‚ÄòLost highway‚Äô will not return any rows if the actual data is ‚ÄòLost Highway‚Äô.\n\n\n\nPostgres provides us with two wild-cards that we can use with LIKE: - % matches any string of characters. - _ matches a single character.\n\nPattern matching with LIKE is case sensitive;\nPostgres also provides the ILIKE keyword that has the same functionality as LIKE but is case-insensitive.\nWith LIKE or ILIKE, the entire string should match the pattern.\nUsing ESCAPE to identify escape character: e.g.¬†WHERE column LIKE '%$%%' ESCAPE '$': matches strings that contains %.\n\n\n\n\nSELECT column1, column2\nFROM table1\nWHERE column1 = value1 OR column1 = value2 OR column1 = value3\n;\nThis can be rewritten more succinctly using the IN operator:\nSELECT column1, column2\nFROM table1\nWHERE column1 IN (value1, value2, value3)\n:\n\n\n\nSelect a range of values, and it can be used for number(BETWEEN 1 AND 5), character(BETWEEN 'e' AND 'm') and datetime(BETWEEN DATE '2021-01-01' AND '2021-11-10').\nBETWEEN is inclusive of both ends of the interval.\n\n\n\nTrying to find NULL values using WHERE column = NULL fails. This is because a NULL value is by defination not known and could be anything, so it‚Äôs not necessarily equal to another NULL. To find NULL values in a column, we can use IS [NOT] NULL.\n\n\n\nIn SQL, we are not required to use the same column and table names in the schema.\n\n\n\nDerived columns in SQL are columns taht are the result of doing operations on existing columns of a table.\nSELECT title, runtime/60. AS runtime_hours\nFROM movies;\nif you divide by 60 instead, SQL assumes that the result of this operation should also be an integer(given that the column runtime is also of type integer), and will return truncated integer values instead of floats.\nSQL doesn‚Äôt know what to call the derived column, and by default you will see ?column? as the column name. We can use an alias to name the new derived column.\nSELECT statement is powerful, but not dangerous. Derived columns returned by Postgres are not saved anywhere, nor do they change existing columns.\n\n\n\nIt enables us to treat a column differently based on the values in each row.\nSELECT \n  title, \n  runtime,\n  CASE\n    WHEN runtime &gt; 90 THEN 'long'\n    WHEN runtime BETWEEN 30 AND 90 THEN 'normal'\n    ELSE 'short'\n  END AS duration\nFROM \n  movies\n;\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n%\nmodulo (remainder)\n\n\n^\nexponentiation\n\n\n@\nabsolute value\n\n\n\n\n\n\nDescription\nExample\n\n\n\n\nabsolute value\nabs(-17.4)\n\n\nsmallest integer not less than argument\nceil(-42.8)\n\n\nexponential\nexp(1.0)\n\n\nlargest integer not greater than argument\nfloor(-42.8)\n\n\nnatural logarithm\nln(2.0)\n\n\nlogarithm to base b\nlog(2.0, 64.0)\n\n\n‚ÄúœÄ‚Äù constant\npi()\n\n\na raised to the power of b\npower(9.0, 3.0)\n\n\nround to s decimal places\nround(42.4382, 2)\n\n\nsquare root\nsqrt(2.0)\n\n\n\nROUND() function only works with the NUMERIC (or equivalently DECIMAL) data type.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nstring || string\nString concatenation\n\n\nstring || non-string or non-string || string\nString concatenation with one non-string input\n\n\nchar_length(string) or character_length(string)\nNumber of characters in string\n\n\nlower(string)\nConvert string to lower case\n\n\nposition(substring in string)\nLocation of specified substring\n\n\nsubstring(string)\nExtract substring\n\n\nupper(string)\nConvert string to upper case\n\n\nlength(string)\nNumber of characters in string\n\n\n\nSELECT\n  UPPER(title),\n  SUBSTRING(title FROM 1 FOR 3) AS \"First 3 characters\",\n  SUBSTRING(title, LENGTH(title) - 3, 3) AS \"LAST 3 characters\"\nFROM\n  movies\n;\n\n\n\nNULLIF(value1, value2) returns null if value1 and value2 are equal. This is helpful for replacing known values with nulls, or prevent, for example, division by zero."
  }
]